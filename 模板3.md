# 拓扑排序模板（C++）

以下是两种常用的拓扑排序实现方法：Kahn算法（基于入度）和DFS算法。

## 方法一：Kahn算法（基于BFS）

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

vector<int> topologicalSort(int n, vector<vector<int>>& graph) {
    vector<int> inDegree(n, 0);
    vector<vector<int>> adj(n); // 邻接表
    
    // 构建图和入度表
    for (auto& edge : graph) {
        int u = edge[0], v = edge[1];
        adj[u].push_back(v);
        inDegree[v]++;
    }
    
    queue<int> q;
    // 将所有入度为0的节点加入队列
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        
        // 减少所有邻居节点的入度
        for (int v : adj[u]) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }
    
    // 如果结果中的节点数不等于总节点数，说明存在环
    if (result.size() != n) {
        return {}; // 返回空数组表示有环，无法拓扑排序
    }
    
    return result;
}

int main() {
    // 示例：6个节点，边为[[5,2],[5,0],[4,0],[4,1],[2,3],[3,1]]
    int n = 6;
    vector<vector<int>> graph = {{5,2}, {5,0}, {4,0}, {4,1}, {2,3}, {3,1}};
    
    vector<int> result = topologicalSort(n, graph);
    
    if (result.empty()) {
        cout << "图中存在环，无法进行拓扑排序" << endl;
    } else {
        cout << "拓扑排序结果: ";
        for (int node : result) {
            cout << node << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

## 方法二：DFS算法

```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

bool dfs(int u, vector<vector<int>>& adj, vector<int>& visited, stack<int>& st) {
    visited[u] = 1; // 标记为正在访问
    
    for (int v : adj[u]) {
        if (visited[v] == 1) return false; // 发现环
        if (visited[v] == 0 && !dfs(v, adj, visited, st)) return false;
    }
    
    visited[u] = 2; // 标记为已访问
    st.push(u);
    return true;
}

vector<int> topologicalSortDFS(int n, vector<vector<int>>& graph) {
    vector<vector<int>> adj(n);
    for (auto& edge : graph) {
        int u = edge[0], v = edge[1];
        adj[u].push_back(v);
    }
    
    vector<int> visited(n, 0); // 0:未访问, 1:正在访问, 2:已访问
    stack<int> st;
    
    for (int i = 0; i < n; i++) {
        if (visited[i] == 0) {
            if (!dfs(i, adj, visited, st)) {
                return {}; // 存在环
            }
        }
    }
    
    vector<int> result;
    while (!st.empty()) {
        result.push_back(st.top());
        st.pop();
    }
    
    return result;
}

int main() {
    int n = 6;
    vector<vector<int>> graph = {{5,2}, {5,0}, {4,0}, {4,1}, {2,3}, {3,1}};
    
    vector<int> result = topologicalSortDFS(n, graph);
    
    if (result.empty()) {
        cout << "图中存在环，无法进行拓扑排序" << endl;
    } else {
        cout << "拓扑排序结果: ";
        for (int node : result) {
            cout << node << " ";
        }
        cout << endl;
    }
    
    return 0;
}
```

## 使用说明

1. **输入格式**：
   - `n`：图中的节点数量
   - `graph`：边的列表，每条边表示为`[u, v]`，表示从节点`u`指向节点`v`的有向边

2. **输出**：
   - 如果图是有向无环图(DAG)，返回一个拓扑排序序列
   - 如果图中存在环，返回空数组

3. **算法选择**：
   - Kahn算法更直观，易于理解，且可以检测环
   - DFS算法在某些情况下可能更高效，但实现稍复杂

4. **时间复杂度**：两种算法的时间复杂度均为O(V+E)，其中V是顶点数，E是边数

根据具体问题选择合适的算法实现拓扑排序。

# 树状数组
```c++
#include <vector>
#include <iostream>
using namespace std;

template<typename T>
class FenwickTree {
private:
    vector<T> tree;
    int n;

public:
    // 构造函数，初始化大小为n+1（树状数组下标从1开始）
    FenwickTree(int size) : n(size), tree(size + 1, 0) {}
    
    // 在位置pos增加value
    void update(int pos, T value) {
        for (; pos <= n; pos += pos & -pos) {
            tree[pos] += value;
        }
    }
    
    // 查询前缀和[1, pos]
    T query(int pos) {
        T sum = 0;
        for (; pos > 0; pos -= pos & -pos) {
            sum += tree[pos];
        }
        return sum;
    }
    
    // 查询区间和[l, r]
    T rangeQuery(int l, int r) {
        return query(r) - query(l - 1);
    }
    
    // 获取原始数组（仅供调试使用）
    vector<T> getOriginalArray() {
        vector<T> arr(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            arr[i] = rangeQuery(i, i);
        }
        return arr;
    }
};

// 示例用法
int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    int n = nums.size();
    
    FenwickTree<int> fenwick(n);
    
    // 构建树状数组
    for (int i = 0; i < n; i++) {
        fenwick.update(i + 1, nums[i]);  // 注意：树状数组下标从1开始
    }
    
    // 测试查询
    cout << "前缀和[1,3]: " << fenwick.query(3) << endl;      // 输出: 6 (1+2+3)
    cout << "区间和[2,4]: " << fenwick.rangeQuery(2, 4) << endl; // 输出: 9 (2+3+4)
    
    // 测试更新
    fenwick.update(2, 3);  // 在位置2增加3
    cout << "更新后区间和[2,4]: " << fenwick.rangeQuery(2, 4) << endl; // 输出: 12 (5+3+4)
    
    return 0;
}
```

# 逆序对
## 归并排序
```c++
class SortWithSwapCount {
private:
    long long swapCount;  // 统计交换次数

    // 归并排序的合并过程
    void merge(vector<int>& arr, int left, int mid, int right) {
        vector<int> temp(right - left + 1);
        int i = left, j = mid + 1, k = 0;
        
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                // 当左半部分的元素大于右半部分的元素时
                // 需要将右半部分的元素移动到左半部分元素的前面
                // 这相当于进行了 (mid - i + 1) 次相邻交换
                swapCount += (mid - i + 1);
                temp[k++] = arr[j++];
            }
        }
        
        // 复制剩余元素
        while (i <= mid) {
            temp[k++] = arr[i++];
        }
        while (j <= right) {
            temp[k++] = arr[j++];
        }
        
        // 将临时数组复制回原数组
        for (int idx = 0; idx < k; idx++) {
            arr[left + idx] = temp[idx];
        }
    }

    // 归并排序递归函数
    void mergeSort(vector<int>& arr, int left, int right) {
        if (left >= right) return;
        
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }

public:
    SortWithSwapCount() : swapCount(0) {}
    
    // 排序并返回交换次数
    long long sortAndCountSwaps(vector<int>& arr) {
        swapCount = 0;
        if (arr.size() <= 1) return 0;
        
        mergeSort(arr, 0, arr.size() - 1);
        return swapCount;
    }
};
/*
usage:
vector<int> arr={4,3,1,2};
SortWithSwapCount sorter;
int cnt = sorter.sortAndCountSwaps(arr);
*/
```

# 李超线段树
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1e6 + 5;
const ll INF = 1e18;

// 李超线段树 - 维护最大值
struct MaxLiChaoTree {
    struct Line {
        ll k, b;
        Line() : k(0), b(-INF) {}
        Line(ll _k, ll _b) : k(_k), b(_b) {}
        ll operator()(ll x) const { return k * x + b; }
    };

    vector<Line> tree;
    int n;

    MaxLiChaoTree(int _n) : n(_n) {
        tree.resize(4 * n);
    }

    void insert(int node, int l, int r, Line line) {
        if (l == r) {
            if (line(l) > tree[node](l)) tree[node] = line;
            return;
        }

        int mid = (l + r) / 2;
        if (line(mid) > tree[node](mid)) {
            swap(tree[node], line);
        }

        if (line(l) > tree[node](l)) {
            insert(2 * node, l, mid, line);
        } else if (line(r) > tree[node](r)) {
            insert(2 * node + 1, mid + 1, r, line);
        }
    }

    void insert(ll k, ll b) {
        insert(1, 1, n, Line(k, b));
    }

    ll query(int node, int l, int r, int x) {
        if (l == r) return tree[node](x);

        int mid = (l + r) / 2;
        ll res = tree[node](x);
        if (x <= mid) {
            res = max(res, query(2 * node, l, mid, x));
        } else {
            res = max(res, query(2 * node + 1, mid + 1, r, x));
        }
        return res;
    }

    ll query(int x) {
        return query(1, 1, n, x);
    }
};

// 李超线段树 - 维护最小值
struct MinLiChaoTree {
    struct Line {
        ll k, b;
        Line() : k(0), b(INF) {}
        Line(ll _k, ll _b) : k(_k), b(_b) {}
        ll operator()(ll x) const { return k * x + b; }
    };

    vector<Line> tree;
    int n;

    MinLiChaoTree(int _n) : n(_n) {
        tree.resize(4 * n);
    }

    void insert(int node, int l, int r, Line line) {
        if (l == r) {
            if (line(l) < tree[node](l)) tree[node] = line;
            return;
        }

        int mid = (l + r) / 2;
        if (line(mid) < tree[node](mid)) {
            swap(tree[node], line);
        }

        if (line(l) < tree[node](l)) {
            insert(2 * node, l, mid, line);
        } else if (line(r) < tree[node](r)) {
            insert(2 * node + 1, mid + 1, r, line);
        }
    }

    void insert(ll k, ll b) {
        insert(1, 1, n, Line(k, b));
    }

    ll query(int node, int l, int r, int x) {
        if (l == r) return tree[node](x);

        int mid = (l + r) / 2;
        ll res = tree[node](x);
        if (x <= mid) {
            res = min(res, query(2 * node, l, mid, x));
        } else {
            res = min(res, query(2 * node + 1, mid + 1, r, x));
        }
        return res;
    }

    ll query(int x) {
        return query(1, 1, n, x);
    }
};

int main() {
    int n, m;
    scanf("%d%d", &n, &m);

    MaxLiChaoTree max_tree(n);
    MinLiChaoTree min_tree(n);

    while (m--) {
        int op;
        scanf("%d", &op);

        if (op == 0) {
            ll k, b;
            scanf("%lld%lld", &k, &b);
            max_tree.insert(k, b);
            min_tree.insert(k, b);
        } else {
            int x;
            scanf("%d", &x);
            ll max_val = max_tree.query(x);
            ll min_val = min_tree.query(x);
            printf("%lld %lld\n", max_val, min_val);
        }
    }

    return 0;
}
```