```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1e6 + 5;
const ll INF = 1e18;

// 李超线段树 - 维护最大值
struct MaxLiChaoTree {
    struct Line {
        ll k, b;
        Line() : k(0), b(-INF) {}
        Line(ll _k, ll _b) : k(_k), b(_b) {}
        ll operator()(ll x) const { return k * x + b; }
    };
    
    vector<Line> tree;
    int n;
    
    MaxLiChaoTree(int _n) : n(_n) {
        tree.resize(4 * n);
    }
    
    void insert(int node, int l, int r, Line line) {
        if (l == r) {
            if (line(l) > tree[node](l)) tree[node] = line;
            return;
        }
        
        int mid = (l + r) / 2;
        if (line(mid) > tree[node](mid)) {
            swap(tree[node], line);
        }
        
        if (line(l) > tree[node](l)) {
            insert(2 * node, l, mid, line);
        } else if (line(r) > tree[node](r)) {
            insert(2 * node + 1, mid + 1, r, line);
        }
    }
    
    void insert(ll k, ll b) {
        insert(1, 1, n, Line(k, b));
    }
    
    ll query(int node, int l, int r, int x) {
        if (l == r) return tree[node](x);
        
        int mid = (l + r) / 2;
        ll res = tree[node](x);
        if (x <= mid) {
            res = max(res, query(2 * node, l, mid, x));
        } else {
            res = max(res, query(2 * node + 1, mid + 1, r, x));
        }
        return res;
    }
    
    ll query(int x) {
        return query(1, 1, n, x);
    }
};

// 李超线段树 - 维护最小值
struct MinLiChaoTree {
    struct Line {
        ll k, b;
        Line() : k(0), b(INF) {}
        Line(ll _k, ll _b) : k(_k), b(_b) {}
        ll operator()(ll x) const { return k * x + b; }
    };
    
    vector<Line> tree;
    int n;
    
    MinLiChaoTree(int _n) : n(_n) {
        tree.resize(4 * n);
    }
    
    void insert(int node, int l, int r, Line line) {
        if (l == r) {
            if (line(l) < tree[node](l)) tree[node] = line;
            return;
        }
        
        int mid = (l + r) / 2;
        if (line(mid) < tree[node](mid)) {
            swap(tree[node], line);
        }
        
        if (line(l) < tree[node](l)) {
            insert(2 * node, l, mid, line);
        } else if (line(r) < tree[node](r)) {
            insert(2 * node + 1, mid + 1, r, line);
        }
    }
    
    void insert(ll k, ll b) {
        insert(1, 1, n, Line(k, b));
    }
    
    ll query(int node, int l, int r, int x) {
        if (l == r) return tree[node](x);
        
        int mid = (l + r) / 2;
        ll res = tree[node](x);
        if (x <= mid) {
            res = min(res, query(2 * node, l, mid, x));
        } else {
            res = min(res, query(2 * node + 1, mid + 1, r, x));
        }
        return res;
    }
    
    ll query(int x) {
        return query(1, 1, n, x);
    }
};

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    
    MaxLiChaoTree max_tree(n);
    MinLiChaoTree min_tree(n);
    
    while (m--) {
        int op;
        scanf("%d", &op);
        
        if (op == 0) {
            ll k, b;
            scanf("%lld%lld", &k, &b);
            max_tree.insert(k, b);
            min_tree.insert(k, b);
        } else {
            int x;
            scanf("%d", &x);
            ll max_val = max_tree.query(x);
            ll min_val = min_tree.query(x);
            printf("%lld %lld\n", max_val, min_val);
        }
    }
    
    return 0;
}
```